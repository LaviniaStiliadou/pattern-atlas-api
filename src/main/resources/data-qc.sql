INSERT INTO public.pattern_language (id, name, uri, graph, logo) VALUES ('6f6a891f-df78-49b6-83cb-2b95c535e1b1', 'Quantum Algorithm Patterns', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns', '[{"x": 634.527023669844, "y": 317.89499219070217, "id": "8bca3490-a040-4d74-84d5-8a3da9a4232f", "vx": 0.03680751673271294, "vy": 0.007728038500160988, "uri": "https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/oracle", "type": "default", "index": 0, "title": "Oracle"}, {"x": 876.3614714751461, "y": 313.73611696743893, "id": "d9608d44-a64d-4c16-a338-aa0b2e17bb6e", "vx": 10.35853568556058, "vy": -5.963396765798682, "uri": "https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/uniformSuperposition", "type": "default", "index": 1, "title": "Uniform Superposition"}, {"x": 728.6939593820944, "y": 253.11604649332358, "id": "30ac5c81-1f9a-499b-b5a3-97f0a236e882", "vx": 10.169004054400817, "vy": -4.76059088938299, "uri": "https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/uncompute", "type": "default", "index": 2, "title": "Uncompute"}, {"x": 865.5856587360386, "y": 166.0393014923956, "id": "3aa1d4fe-cc68-4703-b9c1-999b3943f96d", "vx": 9.04278873158754, "vy": -5.968497789421648, "uri": "https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/creatingEntanglement", "type": "default", "index": 3, "title": "Creating Entanglement"}, {"x": 735.7165162756228, "y": 91.00080463662508, "id": "8b644617-9026-4ef4-afe3-01c8959937e9", "vx": 8.207359463558946, "vy": -4.542771934929312, "uri": "https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/functionTable", "type": "default", "index": 4, "title": "Function Table"}, {"x": 552.7135291917972, "y": 186.5611842313279, "id": "c846f2f2-0913-4efc-8e86-583b68f4bc29", "vx": 0.01584482777466611, "vy": -0.016874378599790005, "uri": "https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/initialization", "type": "default", "index": 5, "title": "Initialization"}]', null);

INSERT INTO public.pattern_schema (pattern_language_id) VALUES ('6f6a891f-df78-49b6-83cb-2b95c535e1b1');

INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('8bca3490-a041-4d74-84d5-8a3da9a5232f', 'Known Uses', 'Known Uses', 6, 'any', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('8bca3490-a040-4d74-84d5-8a3da9a5232f', 'Next', 'Next', 7, 'any', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('8bca3490-a040-4d74-84d5-8a3da9a7232f', 'Context', 'Context', 4, 'any', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('8bca3490-a040-4d74-84d5-8a3da9b4232f', 'Alias', 'Alias', 0, 'any', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('8bca3490-a040-4d74-84d5-8a3da9a4242f', 'Driving Question', 'Driving Question', 3, 'any', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('8bca3490-a040-4d74-84d5-8a3da9a4233f', 'Intend', 'Intend', 2, 'any', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern_section_schema (id, label, name, position, type, pattern_schema_pattern_language_id) VALUES ('45051367-75ca-4905-98e9-a2248e144092', 'Solution', 'Solution', 5, 'any', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');

INSERT INTO public.pattern (id, name, uri, content, icon_url, pattern_language_id) VALUES ('8bca3490-a040-4d74-84d5-8a3da9a4232f', 'Oracle', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/oracle', '{"Next": "An oracle often requires to uncompute its result state, and assumes a properly\nprepared register as input (*initialization*).", "Alias": "Black Box", "Intend": "Quantum algorithms often need to compute values of a function f without\nhaving to know the details how such values are computed.", "Context": "Divide-and-Conquer is a well-established method in computer science to\nsimplify the solution of complex problems. The concept of an oracle (or black box) as\na granule of reuse with hidden internals supports this method for building quantum\nalgorithms.", "Solution": "Oracles are used in problem specific manners. [14] discusses various kinds\nof oracles. Limitations of using oracles are discussed in [26].", "Known Uses": "The algorithms of Deutsch, Deutsch-Jozsa, Bernstein-Vazirani, Simon,\nGrover and others make use of oracles. See [20] for further usages.", "Driving Question": "How can the computation of another quantum algorithm be reused?"}', 'assets/pattern_icons/oracle.PNG', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern (id, name, uri, content, icon_url, pattern_language_id) VALUES ('45051367-75ca-4904-98e9-a2248e144092', 'Phase Shift', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/phaseShift', '{"Next": "A function table based on an indicator function is a phase shift, with G as the\nset of base vectors qualifying under the indicator function. An amplitude\namplification makes use of two phase shifts. A phase shift is used as an oracle.", "Alias": "", "Intend": "In a given register certain qbits should be emphasized.", "Context": "When an algorithm is applied iteratively, and each iteration is assumed to\nimprove the solution, those parts of the solution that did improve should be indicated.\nA phase shift can be such an indication.", "Solution": "The following operator $S^\\varphi_G$ can be efficiently implemented (see [24]) in\nterms of number of gates used:\n$$\\sum_{x=0}^{N-1}a_x|x\\rangle \\mapsto \\sum_{x \\in G} a_x |x \\rangle + \\sum_{x \\notin G} a_x | x \\rangle$$\nThis operator shifts the qbits in $G \\subseteq \\{0, \\ldots , N-1\\}$ (the qbits improved: „good set“) by $\\varphi$ and leaves the other qbits unchanged. There is even a variant of the operator\nthat shifts the phases of the qbits in the good set by different values, i.e.\nphase $\\varphi = \\varphi(x)$", "Known Uses": "The algorithms of Grover, Deutsch-Jozsa etc. use a phase shift.", "Driving Question": "How can important aspects of a state been efficiently distinguished?"}', 'assets/pattern_icons/phase_shift.PNG', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern (id, name, uri, content, icon_url, pattern_language_id) VALUES ('b3663ab8-bf20-435e-9572-ac7e6ea85ba0', 'Uncompute', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/uncompute(akaUnentanglingAkaCopy-uncompute)', '{"Next": "An oracle often produces a state that is an entanglement between the\ncomputational basis and some temporary qbits, thus requires uncompute. A function\ntable may be seen as a special case of an oracle.", "Alias": " Unentangling, Copy-Uncompute", "Intend": "Often, entanglement of the computational basis of a quantum register with\ntemporary qbits (ancilla, workspace) has to be removed to allow proper continuation\nof an algorithm.", "Context": "A computation often needs temporary qbits, and at the end of the\ncomputation these qbits are entangled with the computational basis. This hinders\naccess to the actual result of the computation, especially if the computation was used\njust as an intermediate step within an algorithm.\nFor example, if the computation should produce $\\sum \\alpha_i | \\varphi_i \\rangle$ but in fact it produces $\\sum \\alpha_i \\varphi_i \\rangle | \\psi_i \\rangle$, the temporary qbits $| \\psi_i \\rangle$ can not be simply eliminated unless\n$$ \\sum \\alpha_i \\varphi_i \\rangle | \\psi_i \\rangle = (\\sum \\alpha_i | \\varphi \\rangle)\\otimes \\psi_i \\rangle,$$\ni.e. unless the computational basis and the temporary qbits are separable.", "Solution": "Most algorithms map |x>|0> |0> to |x>|g(x)>|f(x)> to compute a function f\n[8]. I.e. the second qbits represent a workspace that contains garbage g(x) at the end\nof the computation. This garbage has to be set to |0> to allow for proper continuation,\nespecially if future parts of the algorithm expects the workspace to be initialized again\nby |0>.\nMore precisely, assume the computation $U_f$ resulted in\n$$|x\\rangle|0\\rangle|0\\rangle \\mapsto \\sum_y a_y |x\\rangle|y\\rangle |f(x)\\rangle,$$\ni.e. the garbagde state is $|g(x)\\rangle = \\sum_<a_y|y\\rangle$.  Now, a fourth register initialized to |0> is\nadded, and CNOT is applied (bitwise) to this fourth register controlled by the third\nregister: this copies f(x) to the fourth register and $\\sum_y a_y |x\\rangle y\\rangle f(x)\\rangle|f(x)\\rangle$ results. Next, $U_f^{-1}$ is applied to the first three registers, giving |x>|0>|0>|f(x)>. Then, SWAP is\napplied to the last two registers leaving |x>|0>|f(x)>|0>. This now allows to discard\nthe last register leaving |x>|0>|f(x)> as wanted (more details in [8]). [23] discusses\nhow to use uncompute in several situations.", "Known Uses": "Deutsch-Joza, the HHL algorithm [15], quantum walks, realizations of\nclassical circuits as quantum algorithms etc make use of uncompute.", "Driving Question": "How can entanglement be removed that resulted from a computation?"}', 'assets/pattern_icons/uncompute.PNG', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern (id, name, uri, content, icon_url, pattern_language_id) VALUES ('63940a7b-fa03-4f4c-8a21-e891825ad2c8', 'Amplitude Amplification', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/amplitudeAmplification', '{"Next": "Part of the unitary operation $Q$ is the *function table* $S_G^\\pi$ , which is also a special\ncase of a phase shift. Amplitude amplifications are used as oracles.", "Alias": "", "Intend": "Enter your input for this section here.", "Context": "The function table of an indicator function f may list all solutions of a\nproblem (i.e. $f(x) = 1 \\Leftrightarrow x$ solves the problem). By measuring the corresponding state,\na solution is found with a certain probability. But measuring destroys the state, i.e. if a\nsolution is not received by measurement, the computation has to be performed again\nto support another new measurement.\nThus, a mechanism is wanted that doesn’t need measurements and that allows to\ncontinue with the state achieved in case a solution is not found.", "Solution": "State is transformed in such a way that values of interest get a modified\namplitude such that they get a higher probability of being measured after a couple of\niterations [4].\nThe phase shift $S^\\pi_G$ changes the sign of the phase of elements in $G$, the phase shift $S^\\pi_0$ changes the sign of $|0\\rangle$ (the start value of the iteration) and leaves the other\nelements unchanged. Let U be the algorithm for computing approximate solutions\n(not using any measurements). Define the following is unitary operation:\n$$Q = - US_0^\\pi U^{-1}S^\\pi_G$$\nIf U is an algorithm that succeeds with a solution with probability t, 1/t iterations are\nrequired on the average to find a solution. U$|0\\rangle$ is assumed to have a non-zero amplitude in G, otherwise no speedup can be achieved. If U has this property, Q will\nproduce a solution within $O(\\sqrt{1/t})$ iterations - which is a quadratic speedup. The\nnumber of iterations to be performed with Q is about\n$$\\frac{\\pi}{4} \\cdot \\frac{1}{|P_GU|O\\rangle|}$$\nwhere $P_G$ is the projection onto the subspace spanned by $G$.", "Known Uses": "The algorithms of Grover and Simons, for example, make use of\namplitude amplification. Also, the HHL algorithm for solving linear equations [15]\nuses this pattern. The state preparation algorithm of [25] uses amplitude amplification\ntoo. [4] discusses more algorithms making use of it.", "Driving Question": "How can the probability of finding a solution be increased?"}', 'assets/pattern_icons/amplitude_amplification.PNG', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern (id, name, uri, content, icon_url, pattern_language_id) VALUES ('00e66829-b566-49a7-a38d-b945bce48f84', 'Quantum-Classic Split', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/quantum-classicSplit', '{"Next": "Data is passed from the classical part of the solution to the quantum part by\nproper initialization.", "Alias": "", "Intend": "The solution of a problem is often not achieved by only using a quantum\ncomputer. Thus, the solution is performed partially on a classical computer and\npartially on a quantum computer, and both parts of the solution interact.", "Context": "Some quantum algorithms inherently require pre- or post-processing on a\nclassical device, resulting in a split of the solution into a classical part and a quantum\npart.\nAlso, if a quantum computer has a low number of qubits or its gates are noisy, a\nsolution of a problem may have to be separated into a part executed on a quantum\ncomputer and a part executed on a classical computer [22].", "Solution": "The sheer fact that a split of the algorithms may be done is important. How\nsuch a split is applied is problem dependent.", "Known Uses": "Shor''s algorithm or Simon’s algorithm inherently make use of classical\npost-processing. The algorithm in [11] to solve combinatorial optimization problems\nuses classical pre-processing. The algorithm of [2] uses a split into a quantum part of\nthe solution and a classical part to enable factorization on NISQ devices.", "Driving Question": "How can a solution be split between a quantum computer and a\nclassical computer?"}', 'assets/pattern_icons/quantum_classic_split.PNG', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern (id, name, uri, content, icon_url, pattern_language_id) VALUES ('c846f2f2-0913-4efc-8e86-583b68f4bc29', 'Initialization', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/initialization', '{"Next": "Often, after initialization the register must be brought into a state of uniform\nsuperposition. Function tables require the initializations discussed here. An initialized\nregister may become input to an oracle.", "Alias": "State Preparation", "Intend": "At the beginning of a quantum algorithm, the quantum register manipulated\nby the algorithm must be initialized. The initialization must be as easy as possible,\nconsidering requirements of the steps of the algorithm.", "Context": "An algorithm typically requires input representing the parameters of the\nproblem to be solved. Most quantum algorithms encode this input as part of the\nunitary transformations making up the quantum algorithm. E.g. if the overall\nalgorithm is $U=U_n \\cdot \\ldots \\cdot U_i \\cdot U_{i-1} \\cdot \\ldots \\cdot U1$, then $U_1, \\ldots , U_{i-1}$ are operators that furnish the\nregister to hold the parameters of the problem solved by the following operators $U_i,\\ldots,U_n$. However, the initial state operated on by $U_{i-1} \\cdot \\ldots \\cdot U_1$ must be set; $U_{i-1} \\cdot \\ldots \\cdot U_1$ is\ncalled state preparation [25].", "Solution": "Often, the register will be initialized as the unit vector |0…0>. This\nregister may have certain ancilla bits or workspace bits distinguished that are used to\nstore intermediate results, to control the processing of the algorithm etc..\nFor example, the register is initialized with $|0\\rangle^{\\bigotimes n} |0\\rangle^{\\bigotimes m}$ (where the second part of\nthe register consists of workspace bits) in order to compute the function table of the\nBoolean function $f : {\\{0,1\\}}^n \\mapsto {\\{0,1\\}}^m$.\nAn initialization with $|0\\rangle^{\\bigotimes n} |1\\rangle^{\\bigotimes m}$ supports to reveal membership in a set which is\ndefined based on an indicator function (used to solve decision problems, for example)\nby changing the sign of the qbits representing members of this set.\nBased on these simple initializations, more advanced states can be prepared. For\nexample, [7] discusses several algorithms to load classical bits into a quantum\nregister. [25] presents how to load a complex vector, [8] how to load a real vector\nbased on corresponding data structures; thus, a matrix can be loaded as a set of\nvectors [18].", "Known Uses": "All algorithms must be initialized somehow.", "Driving Question": "How can the input of a quantum register be initialized in a straightforward\nmanner, considering immediate requirements of the following steps of the quantum algorithm?"}', 'assets/pattern_icons/initialization.PNG', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern (id, name, uri, content, icon_url, pattern_language_id) VALUES ('1ab2404a-89ed-42f8-a666-02962a864ee9', 'Speedup via Verifying', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/speedupViaVerifying', '{"Next": "The verification is performed as an oracle.", "Alias": "", "Intend": "Verifying whether a claimed solution is correct or not is sometimes simple.\nSuch verifications may then be used to speedup solving a corresponding problem.", "Context": "Often, it is hard to find a solution of a problem, but verifying whether a\nclaimed solution is correct is simple. For example, factorizing a number is hard, but\nmultiplying numbers is simple. Thus, when a given list of prime numbers is claimed\nto be the factorization of a certain number, multiplying the prime numbers and\ncomparing the result with the certain number is a simple way of verification.", "Solution": "Solving certain problems can be speedup by first listing all possible\nsolutions, then scanning through the list and verifying whether the current member of\nthe list at hand is a solution or not.\nThe verification of the possible solutions is done via an oracle. Scanning is done by\nmeans of the Grover algorithm, thus,$O(\\sqrt{n})$ invocations of the Oracle function\ndetermines the solution. A prerequisite of this pattern is that solutions can be detected\nby means of oracle.", "Known Uses": "Cracking keys, finding Hamiltonian cycles, solving 3-SAT, the Traveling\nSalesman Problem etc can be approached this way.", "Driving Question": "How can a speedup be achieved when verifying a solution is simple?"}', 'assets/pattern_icons/speedup_via_verifaction.PNG', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern (id, name, uri, content, icon_url, pattern_language_id) VALUES ('d9608d44-a64d-4c16-a338-aa0b2e17bb6e', 'Uniform Superposition', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/uniformSuperposition', '{"Next": "Creating uniform superposition makes use of initialization. A register in uniform superposition may be entangled. A register in uniform superposition may be input to an oracle.", "Alias": "", "Intend": "Typically, the individual qbits of a quantum register have to be in multiple states at the same time without preferring any at these states at the beginning of the computation.", "Context": "One origin of the power of quantum algorithms stems from quantum parallelism, i.e. the ability of a quantum register to represent multiple values at the same time. This is achieved by bringing (a subset of) the qbits of a quantum register into superposition. Many algorithms assume that at the beginning this superposition is uniform, i.e. the probability of measuring any of the qbits is the same.", "Solution": "Uniform superposition is achieved by initializing the quantum register as the unit vector $|0...0\\rangle$ and applying the Hadamard tranformation afterwards:  \n$$H^{\\bigotimes n}(|0\\rangle^{n})=\\frac{1}{\\sqrt{2^n}}\\sum_ {x=0}^{2^n-1}|x\\rangle$$\nIn case the quantum register includes ancilla bits or workspace bits in addition to the computational basis, the computational basis is brought into superposition as described. The other bits may be brought into superposition themselves or not. This is achieved by using a tensor product $H^{\\bigotimes n}\\bigotimes U$, where $H^{\\bigotimes n}$ operates on the computational basis and $U$ operates on the other bits (e.g., $U=I$ in case the other bits are not brought into superposition).", "Known Uses": "Most algorithms make use of uniform superposition", "Driving Question": "How can an equally weighted superposition of all possible states of the qbits of a quantum register be created?"}', 'assets/pattern_icons/superposition.PNG', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern (id, name, uri, content, icon_url, pattern_language_id) VALUES ('8b644617-9026-4ef4-afe3-01c8959937e9', 'Function Table', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/functionTable', '{"Next": "Function tables require initialization discussed before. Uniform superposition\nof the computational basis is established before the function table is computed.\nAmplitude amplification is a generalization of function tables. The computation is\nperformed by an oracle. Often, uncompute is required to continue processing.", "Alias": "", "Intend": "Some problems can be reduced to determining global properties of a\nfunction. For that purpose, the corresponding function table should be computed\nefficiently and made available for further analysis.", "Context": "In order to compute the function table of a function\n$f : {\\{0,1\\}}^n \\mapsto {\\{0,1\\}}^m$ ,\na classical algorithm requires to invoke the function for each value of the domain.\nQuantum parallelism allows to compute the values of such a finite Boolean function\nas a whole in a single step. This can be used to speedup finding global properties of\nthe corresponding function. Note, that in case m=1 the Boolean function is often an\nindicator function used to determine solutions of a decision problem.", "Solution": "The quantum register is split into the computational basis (the domain of\nthe function f) consisting of n qbits x, and a workspace consisting of m qbits y, which\nis used to hold the values of f. Based on this, the unitary operator\n$$U_f |x,y\\rangle = |x,y \\oplus f(x)\\rangle$$\nis defined.\nAfter initializing the register with $|0\\rangle^{\\oplus n}|0\\rangle^{\\oplus m}$, the computational basis is brought\ninto uniform superposition via $H^{\\otimes n}$ leaving the workspace unchanged, and then the\noperator $U_f$ is applied only once resulting in the function table:\n$$|O \\rangle^{\\otimes n}|O \\rangle^{\\otimes m} \\mapsto(\\frac{1}{\\sqrt{2^n}} \\sum_x |x\\rangle)\\otimes|0\\rangle^{\\otimes m} \\mapsto \\frac{1}{\\sqrt{2^n}} \\sum_x |x\\rangle | f(x) \\rangle$$\nIn case of an indicator function f (e.g. if f is representing a decision problem), the\nregister is initialized with $|0\\rangle^{\\oplus n}|1\\rangle.$ Uniform superposition of the complete register is\nfurnished by $H^{\\otimes n +1}$. Applying $U_f$ finally results in\n$$|O \\rangle^{\\otimes n}|1\\rangle \\mapsto(\\frac{1}{\\sqrt{2^n}} \\sum_x |x\\rangle) \\otimes|-\\rangle \\mapsto (\\frac{1}{\\sqrt{2^n}} \\sum_x^{2^n-1} (-1)^{f(x)} |x \\rangle) \\otimes | -\\rangle$$\nThus, members of the computational basis indicate by their sign whether they are\ndetected by the indicator function (minus sign) or not (plus sign) - aka „phase\nkickback“.", "Known Uses": "The algorithms of Deutsch, Deutsch-Jozsa, Grover, Shor and others\nmake use of function tables.", "Driving Question": "How can a function table of a finite Boolean function be computed?"}', 'assets/pattern_icons/function-table.PNG', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
INSERT INTO public.pattern (id, name, uri, content, icon_url, pattern_language_id) VALUES ('4c40e4af-58f3-42ac-a28a-9cc7cb0335e0', 'Creating Entanglement', 'https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/creatingEntanglement', '{"Next": "Enter your input for this section here.", "Alias": "", "Intend": "A strong correlation between qbits of a quantum register is often needed in\norder to enable algorithms that offer a speedup compared to classical algorithms.", "Context": "Entanglement is one of the causes of the power of quantum algorithms (see\n[5], although entanglement is not a necessity [3]). A quantum algorithm showing\nexponential speedup requires entanglement [17]. Thus, after initialization of a\nquantum register it should often be entangled for its further processing.", "Solution": "Several approaches can be taken to create an entangled state. For example,\nassume a binary function $f : {\\{0,1\\}}^n \\mapsto {\\{0,1\\}}^m$. and the corresponding unitary operation\n$$U_f : {\\{0,1\\}}^{n+m} \\mapsto {\\{0,1\\}}^{n+m}, \\ U_f : {\\{0,1\\}}^{n+m} \\mapsto {\\{0,1\\}}^{n+m}$$\nHow can an equally weighted superposition of all possible states of the\nqbits of a quantum register be created? ", "Known Uses": "Enter your input for this section here.", "Driving Question": "How can an entangled state be created?"}', '', '6f6a891f-df78-49b6-83cb-2b95c535e1b1');
